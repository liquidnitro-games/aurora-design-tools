<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hivemind: Mirror Escape</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      background: radial-gradient(circle at top, #202637 0%, #05060a 60%, #020308 100%);
      color: #f5f5f5;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    #wrapper {
      position: relative;
      padding: 16px;
      border-radius: 24px;
      background: rgba(10, 12, 20, 0.9);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.85);
    }
    canvas {
      display: block;
      border-radius: 18px;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.7);
      background: radial-gradient(circle at top, #151827 0%, #05070d 60%, #020308 100%);
    }
    #menu,
    #overlay {
      position: absolute;
      inset: 16px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at center, rgba(22, 26, 44, 0.98), rgba(5, 6, 12, 0.98));
      border-radius: 18px;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
    }
    #overlay {
      display: none;
    }
    h1 {
      font-size: 32px;
      letter-spacing: 2px;
      margin-bottom: 16px;
      text-transform: uppercase;
      text-align: center;
    }
    h2 {
      font-size: 20px;
      margin-bottom: 12px;
      text-align: center;
    }
    p {
      margin: 4px 0;
      opacity: 0.9;
    }
    .button-row {
      margin-top: 16px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, #3b82f6, #06b6d4);
      color: #f9fafb;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.03em;
      box-shadow: 0 6px 16px rgba(15, 118, 226, 0.4);
      transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, filter 0.08s ease-out;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(15, 118, 226, 0.55);
      filter: brightness(1.07);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(15, 118, 226, 0.6);
      filter: brightness(0.97);
    }
    .subtle {
      font-size: 12px;
      opacity: 0.7;
      text-align: center;
      margin-top: 8px;
    }
    .tagline {
      font-size: 13px;
      opacity: 0.8;
      margin-bottom: 8px;
      text-align: center;
    }
    .pill {
      font-size: 11px;
      opacity: 0.8;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
  </style>
</head>
<body>
  <div id="wrapper">
    <canvas id="game" width="640" height="480"></canvas>

    <!-- MAIN MENU -->
    <div id="menu">
      <div class="pill">Top-Down Hivemind Puzzle</div>
      <h1>Hivemind: Mirror Escape</h1>
      <p class="tagline">One mind. Two cubes. Every move matters.</p>

      <div class="button-row">
        <button id="btnStart">Start Game</button>
        <button id="btnLevel1">Level 1</button>
        <button id="btnLevel2">Level 2</button>
        <button id="btnLevel3">Level 3</button>
      </div>

      <div style="margin-top: 18px; text-align: center; max-width: 360px;">
        <h2>How to Play</h2>
        <p>Move the blue cube. The orange cube copies every move.</p>
        <p>Avoid red traps and moving enemies. Guide both cubes to the green exit tile.</p>
        <p class="subtle">Controls: Arrow keys / WASD • R = Restart • Esc = Menu</p>
      </div>
    </div>

    <!-- OVERLAY (Win / Lose) -->
    <div id="overlay">
      <h2 id="overlayTitle">Level Complete</h2>
      <p id="overlayMessage"></p>
      <div class="button-row">
        <button id="btnNext">Next Level</button>
        <button id="btnRetry">Retry</button>
        <button id="btnMenu">Main Menu</button>
      </div>
      <p class="subtle" id="overlayHint"></p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const menuEl = document.getElementById("menu");
    const overlayEl = document.getElementById("overlay");
    const overlayTitleEl = document.getElementById("overlayTitle");
    const overlayMessageEl = document.getElementById("overlayMessage");
    const overlayHintEl = document.getElementById("overlayHint");

    const btnStart = document.getElementById("btnStart");
    const btnLevel1 = document.getElementById("btnLevel1");
    const btnLevel2 = document.getElementById("btnLevel2");
    const btnLevel3 = document.getElementById("btnLevel3");
    const btnNext = document.getElementById("btnNext");
    const btnRetry = document.getElementById("btnRetry");
    const btnMenu = document.getElementById("btnMenu");

    const TILE = 40;

    // LEVEL LEGEND:
    // # = wall
    // . or space = floor
    // A = Player 1 start (blue)
    // B = Player 2 start (orange)
    // E = Exit
    // T = Trap (death)
    // V = Void (death)
    // M = Moving enemy (horizontal patrol)

    const LEVELS = [
      {
        name: "Level 1: First Link",
        map: [
          "################",
          "#A.....#......B#",
          "#.###..#..###..#",
          "#.#....#..#E#..#",
          "#.#.####..#.#..#",
          "#.#......T#.#..#",
          "#.#########.#..#",
          "#...........#..#",
          "################"
        ]
      },
      {
        name: "Level 2: Offset Arena",
        map: [
          "####################",
          "#A....E.........B###",
          "#....###........####",
          "#................###",
          "#..###.........T.###",
          "#..#..T.......###.##",
          "#..#..###........###",
          "#..#..............##",
          "#..############..###",
          "#................###",
          "####################"
        ]
      },
      {
        name: "Level 3: Tight Mirage",
        map: [
          "########################",
          "#A............E.....B###",
          "#..M...##............###",
          "#.####..##########...###",
          "#......T.......##...####",
          "#..############.###.####",
          "#..#..........#.....####",
          "#..#.########.#.#####.##",
          "#..#...........#.....###",
          "#..#############.....###",
          "########################"
        ]
      }
    ];

    let currentLevelIndex = 0;
    let grid = [];
    let width = 0;
    let height = 0;

    const players = [
      { x: 0, y: 0, color: "#3b82f6" }, // Blue
      { x: 0, y: 0, color: "#f97316" }  // Orange
    ];

    let exitTiles = [];
    let movesCount = 0;
    let levelState = "menu"; // "menu" | "playing" | "won" | "lost"
    let lastTime = 0;

    // Moving enemies
    let enemies = [];

    // AUDIO (simple tones)
    let audioCtx = null;
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    function playTone(freq, duration, type = "sine", volume = 0.2) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      osc.start(now);
      osc.stop(now + duration);
    }
    const SFX = {
      move: () => playTone(520, 0.07, "triangle", 0.12),
      hit: () => playTone(120, 0.25, "sawtooth", 0.2),
      win: () => {
        playTone(660, 0.15, "sine", 0.18);
        setTimeout(() => playTone(880, 0.2, "sine", 0.18), 130);
      }
    };

    function loadLevel(index) {
      currentLevelIndex = index;
      const level = LEVELS[index];
      const raw = level.map;
      height = raw.length;
      width = raw[0].length;

      canvas.width = width * TILE;
      canvas.height = height * TILE;

      grid = [];
      exitTiles = [];
      enemies = [];
      movesCount = 0;

      for (let y = 0; y < height; y++) {
        const row = [];
        for (let x = 0; x < width; x++) {
          let ch = raw[y][x];
          if (ch === "A") {
            players[0].x = x;
            players[0].y = y;
            ch = "."; // floor
          } else if (ch === "B") {
            players[1].x = x;
            players[1].y = y;
            ch = ".";
          } else if (ch === "E") {
            exitTiles.push({ x, y });
          } else if (ch === "M") {
            // Create a horizontal patrolling enemy
            let minX = x;
            let maxX = x;
            // scan left until wall
            let lx = x - 1;
            while (lx >= 0 && raw[y][lx] !== "#") {
              minX = lx;
              lx--;
            }
            // scan right until wall
            let rx = x + 1;
            while (rx < width && raw[y][rx] !== "#") {
              maxX = rx;
              rx++;
            }
            enemies.push({
              x,
              y,
              minX,
              maxX,
              dir: 1,
              timer: 0
            });
            ch = "."; // underlying floor
          }
          row.push(ch);
        }
        grid.push(row);
      }

      levelState = "playing";
      hideMenu();
      hideOverlay();
    }

    function isWalkable(x, y) {
      if (x < 0 || y < 0 || x >= width || y >= height) return false;
      const ch = grid[y][x];
      return ch !== "#" && ch !== undefined;
    }

    function isDeadTile(x, y) {
      if (x < 0 || y < 0 || x >= width || y >= height) return true;
      const ch = grid[y][x];
      return ch === "T" || ch === "V";
    }

    function isExit(x, y) {
      return exitTiles.some(e => e.x === x && e.y === y);
    }

    function bothOnExit() {
      return exitTiles.length > 0 &&
        isExit(players[0].x, players[0].y) &&
        isExit(players[1].x, players[1].y);
    }

    function checkEnemyCollision() {
      if (levelState !== "playing") return;
      for (const e of enemies) {
        for (const p of players) {
          if (e.x === p.x && e.y === p.y) {
            levelState = "lost";
            SFX.hit();
            showOverlay(false);
            return;
          }
        }
      }
    }

    function updateEnemies(dt) {
      const stepInterval = 0.35; // seconds per tile move
      enemies.forEach(e => {
        e.timer += dt;
        while (e.timer >= stepInterval) {
          e.timer -= stepInterval;

          let nx = e.x + e.dir;
          // Flip direction if hitting patrol bounds or wall
          if (nx < e.minX || nx > e.maxX || !isWalkable(nx, e.y)) {
            e.dir *= -1;
            nx = e.x + e.dir;
            if (!isWalkable(nx, e.y)) {
              // stuck, do nothing
              continue;
            }
          }
          e.x = nx;
        }
      });
    }

    function step(dx, dy) {
      if (levelState !== "playing") return;

      initAudio(); // ensure audio is ready on first interaction

      const newPositions = players.map(p => ({ x: p.x, y: p.y }));
      let anyMoved = false;

      for (let i = 0; i < players.length; i++) {
        const p = players[i];
        const nx = p.x + dx;
        const ny = p.y + dy;
        if (isWalkable(nx, ny)) {
          newPositions[i].x = nx;
          newPositions[i].y = ny;
          anyMoved = true;
        }
      }

      if (!anyMoved) return;

      // Apply movement
      for (let i = 0; i < players.length; i++) {
        players[i].x = newPositions[i].x;
        players[i].y = newPositions[i].y;
      }
      movesCount++;
      SFX.move();

      // Check death from tiles
      for (let i = 0; i < players.length; i++) {
        if (isDeadTile(players[i].x, players[i].y)) {
          levelState = "lost";
          SFX.hit();
          showOverlay(false);
          return;
        }
      }

      // Check enemy collision right after moving
      checkEnemyCollision();
      if (levelState !== "playing") return;

      // Check win
      if (bothOnExit()) {
        levelState = "won";
        SFX.win();
        showOverlay(true);
      }
    }

    function resetLevel() {
      loadLevel(currentLevelIndex);
    }

    function showMenu() {
      levelState = "menu";
      menuEl.style.display = "flex";
      hideOverlay();
    }
    function hideMenu() {
      menuEl.style.display = "none";
    }

    function showOverlay(won) {
      overlayEl.style.display = "flex";
      const level = LEVELS[currentLevelIndex];
      overlayTitleEl.textContent = won ? "Level Complete" : "You Died";
      overlayMessageEl.textContent = won
        ? `${level.name} cleared in ${movesCount} moves.`
        : `Try a different sequence of moves. Watch both cubes and enemy routes.`;

      overlayHintEl.textContent = won
        ? "Tip: Use walls to desync cubes before moving into enemy lanes."
        : "Tip: Let one cube bump into walls to offset positions and dodge the enemy.";

      // Button visibility
      if (won && currentLevelIndex < LEVELS.length - 1) {
        btnNext.style.display = "inline-block";
      } else {
        btnNext.style.display = "none";
      }
    }
    function hideOverlay() {
      overlayEl.style.display = "none";
    }

    // RENDERING
    function drawTile(x, y, ch) {
      const px = x * TILE;
      const py = y * TILE;

      // Base floor
      if (ch === "#" ) {
        // Wall
        const grd = ctx.createLinearGradient(px, py, px, py + TILE);
        grd.addColorStop(0, "#111827");
        grd.addColorStop(1, "#020617");
        ctx.fillStyle = grd;
        ctx.fillRect(px, py, TILE, TILE);

        // Soft top highlight
        ctx.fillStyle = "rgba(148, 163, 184, 0.24)";
        ctx.fillRect(px, py, TILE, 4);
      } else {
        // Floor
        const grd = ctx.createRadialGradient(
          px + TILE / 2, py + TILE / 2, 4,
          px + TILE / 2, py + TILE / 2, TILE
        );
        grd.addColorStop(0, "#0f172a");
        grd.addColorStop(1, "#020617");
        ctx.fillStyle = grd;
        ctx.fillRect(px, py, TILE, TILE);

        // Glow border
        ctx.strokeStyle = "rgba(51, 65, 85, 0.5)";
        ctx.lineWidth = 1;
        ctx.strokeRect(px + 0.5, py + 0.5, TILE - 1, TILE - 1);
      }

      // Special tiles
      if (ch === "E") {
        // Exit glow
        const cx = px + TILE / 2;
        const cy = py + TILE / 2;
        const rg = ctx.createRadialGradient(cx, cy, 2, cx, cy, TILE / 1.4);
        rg.addColorStop(0, "rgba(34,197,94,0.85)");
        rg.addColorStop(1, "rgba(22,101,52,0.01)");
        ctx.fillStyle = rg;
        ctx.fillRect(px, py, TILE, TILE);

        ctx.fillStyle = "#22c55e";
        ctx.fillRect(px + 10, py + 10, TILE - 20, TILE - 20);
        ctx.shadowColor = "rgba(34,197,94,0.9)";
        ctx.shadowBlur = 18;
        ctx.strokeStyle = "rgba(190, 242, 100, 0.7)";
        ctx.lineWidth = 2;
        ctx.strokeRect(px + 10, py + 10, TILE - 20, TILE - 20);
        ctx.shadowBlur = 0;
      } else if (ch === "T") {
        // Trap
        ctx.fillStyle = "#7f1d1d";
        ctx.fillRect(px + 4, py + 4, TILE - 8, TILE - 8);
        ctx.strokeStyle = "#ef4444";
        ctx.lineWidth = 2;
        ctx.strokeRect(px + 6, py + 6, TILE - 12, TILE - 12);
      } else if (ch === "V") {
        // Void
        ctx.fillStyle = "#000000";
        ctx.fillRect(px + 3, py + 3, TILE - 6, TILE - 6);
      }
    }

    function drawPlayer(p) {
      const px = p.x * TILE;
      const py = p.y * TILE;
      const size = TILE * 0.7;
      const offset = (TILE - size) / 2;

      const cx = px + TILE / 2;
      const cy = py + TILE / 2;
      const glow = ctx.createRadialGradient(cx, cy, 2, cx, cy, TILE);
      glow.addColorStop(0, p.color.replace("f6", "ff"));
      glow.addColorStop(1, "rgba(15,23,42,0)");
      ctx.fillStyle = glow;
      ctx.fillRect(px, py, TILE, TILE);

      ctx.shadowColor = p.color;
      ctx.shadowBlur = 18;
      ctx.fillStyle = p.color;
      roundedRect(ctx, px + offset, py + offset, size, size, 8);
      ctx.fill();
      ctx.shadowBlur = 0;

      // subtle top highlight
      const grad = ctx.createLinearGradient(
        px + offset,
        py + offset,
        px + offset,
        py + offset + size
      );
      grad.addColorStop(0, "rgba(248,250,252,0.5)");
      grad.addColorStop(0.4, "rgba(248,250,252,0.0)");
      ctx.fillStyle = grad;
      roundedRect(ctx, px + offset, py + offset, size, size, 8);
      ctx.fill();
    }

    function drawEnemy(e) {
      const px = e.x * TILE;
      const py = e.y * TILE;
      const size = TILE * 0.6;
      const offset = (TILE - size) / 2;

      const cx = px + TILE / 2;
      const cy = py + TILE / 2;
      const glow = ctx.createRadialGradient(cx, cy, 2, cx, cy, TILE);
      glow.addColorStop(0, "rgba(236,72,153,1)");
      glow.addColorStop(1, "rgba(15,23,42,0)");
      ctx.fillStyle = glow;
      ctx.fillRect(px, py, TILE, TILE);

      ctx.shadowColor = "rgba(236,72,153,0.9)";
      ctx.shadowBlur = 16;
      ctx.fillStyle = "#ec4899";

      // diamond shape
      ctx.beginPath();
      ctx.moveTo(px + TILE / 2, py + offset);
      ctx.lineTo(px + TILE - offset, py + TILE / 2);
      ctx.lineTo(px + TILE / 2, py + TILE - offset);
      ctx.lineTo(px + offset, py + TILE / 2);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function roundedRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function draw(timestamp) {
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Background vignette
      const bg = ctx.createRadialGradient(
        canvas.width / 2,
        canvas.height / 4,
        10,
        canvas.width / 2,
        canvas.height / 2,
        Math.max(canvas.width, canvas.height)
      );
      bg.addColorStop(0, "#020617");
      bg.addColorStop(1, "#020617");
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Update enemies in real time
      if (levelState === "playing") {
        updateEnemies(dt);
        checkEnemyCollision();
      }

      // Grid
      if (grid.length > 0) {
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let ch = grid[y][x];
            // Force display of exit from exitTiles so A/B removal doesn't matter
            if (isExit(x, y) && ch !== "E") ch = "E";
            drawTile(x, y, ch);
          }
        }

        // Enemies
        enemies.forEach(drawEnemy);

        // Players
        players.forEach(drawPlayer);

        // HUD text
        ctx.fillStyle = "#e5e7eb";
        ctx.font = "14px system-ui";
        ctx.globalAlpha = 0.9;
        const levelName = LEVELS[currentLevelIndex]?.name || "";
        ctx.fillText(levelName, 10, 18);
        ctx.fillText(`Moves: ${movesCount}`, 10, 36);
        ctx.globalAlpha = 1;
      }

      requestAnimationFrame(draw);
    }

    // INPUT
    window.addEventListener("keydown", (e) => {
      if (e.key === " " || e.key === "ArrowUp" || e.key === "ArrowDown" ||
          e.key === "ArrowLeft" || e.key === "ArrowRight" ||
          e.key.toLowerCase() === "w" || e.key.toLowerCase() === "a" ||
          e.key.toLowerCase() === "s" || e.key.toLowerCase() === "d") {
        e.preventDefault();
      }

      if (levelState === "menu") {
        if (e.key === "Enter") {
          initAudio();
          loadLevel(0);
        }
        return;
      }

      if (e.key === "Escape") {
        showMenu();
        return;
      }
      if (e.key.toLowerCase() === "r") {
        resetLevel();
        return;
      }

      let dx = 0, dy = 0;
      switch (e.key) {
        case "ArrowUp":
        case "w":
        case "W":
          dy = -1;
          break;
        case "ArrowDown":
        case "s":
        case "S":
          dy = 1;
          break;
        case "ArrowLeft":
        case "a":
        case "A":
          dx = -1;
          break;
        case "ArrowRight":
        case "d":
        case "D":
          dx = 1;
          break;
      }

      if (dx !== 0 || dy !== 0) {
        step(dx, dy);
      }
    });

    // BUTTONS
    btnStart.addEventListener("click", () => {
      initAudio();
      loadLevel(0);
    });
    btnLevel1.addEventListener("click", () => {
      initAudio();
      loadLevel(0);
    });
    btnLevel2.addEventListener("click", () => {
      initAudio();
      loadLevel(1);
    });
    btnLevel3.addEventListener("click", () => {
      initAudio();
      loadLevel(2);
    });

    btnRetry.addEventListener("click", () => {
      resetLevel();
    });
    btnMenu.addEventListener("click", () => {
      showMenu();
    });
    btnNext.addEventListener("click", () => {
      const nextIndex = Math.min(currentLevelIndex + 1, LEVELS.length - 1);
      loadLevel(nextIndex);
    });

    hideOverlay();
    requestAnimationFrame(draw);
  </script>
</body>
</html>
